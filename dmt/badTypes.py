#!/usr/bin/env python3
# vim: set expandtab ts=8 sts=4 shiftwidth=4
#
# (C) Semantix Information Technologies.
#
# Semantix Information Technologies is licensing the code of the
# Data Modelling Tools (DMT) in the following dual-license mode:
#
# Commercial Developer License:
#       The DMT Commercial Developer License is the suggested version
# to use for the development of proprietary and/or commercial software.
# This version is for developers/companies who do not want to comply
# with the terms of the GNU Lesser General Public License version 2.1.
#
# GNU LGPL v. 2.1:
#       This version of DMT is the one to use for the development of
# applications, when you are willing to comply with the terms of the
# GNU Lesser General Public License version 2.1.
#
# Note that in both cases, there are no charges (royalties) for the
# generated code.
#
'''
Code Integrator

This is the core of the "glue" generators that Semantix developed for
the European research project ASSERT. It has been enhanced in the
context of Data Modelling and Data Modelling Tuning projects,
and continuous to evolve over the course of other projects.

This code starts by reading the AADL specification of the system.
It then generates the runtime bridge-code that will map the message
data structures from those generated by the Semantix Certified ASN.1
compiler to/from those generated by the modeling tool used to
functionally model the APLC subsystem (e.g. SCADE, ObjectGeode,
Matlab/Simulink, C, Ada, etc).

The code generation is done via user-visible (and editable) backends.

There are three kinds of backends:

1. Synchronous backends
=======================

For these, the working logic is:

for each subprogram implementation
    Load B mapper
    call OnStartup
    for each subprogram param
        Call OnBasic/OnSequence/OnEnumerated etc
    call OnShutdown

That is, there is OnStartup/OnInteger/OnSequence/.../OnShutdown cycle
done PER EACH SUBPROGRAM.

2. Asynchronous backends
========================

Asynchronous backends are only generating standalone encoders and decoders
(they are not doing this per sp.param).

The working logic is therefore different

OnStartup called ONCE for each async backend in use (used by this system's PIs)
Via the asynchronous.py, after visiting all params and collecting them,
for each asn.1 type that is actually used (at least once) as a param:
    Call Encoder and Decoder
Call OnShutdown ONCE for each async backend in use (used by this system's PIs)

3. Special backends
===================

GUI, Python, (VHDL?), etc...

These have custom requirements, so each one is handled by specific AADL2GLUEC
code. As it is now, the pattern follows that of the synchronous backends,
but with an extra call to OnFinal at the end.
'''

import os
import sys

from typing import cast, Optional, Dict, List, Tuple, Any  # NOQA pylint: disable=unused-import

from .commonPy.cleanupNodes import DiscoverBadTypes
from .commonPy.asnParser import Filename, Typename, AST_Lookup, AST_TypesOfFile, AST_Leaftypes  # NOQA pylint: disable=unused-import
from .commonPy.asnAST import AsnNode  # NOQA pylint: disable=unused-import
from .commonPy.aadlAST import ApLevelContainer, Param  # NOQA pylint: disable=unused-import
from .commonPy import asnParser  # NOQA pylint: disable=unused-import
from .commonPy import verify  # NOQA pylint: disable=unused-import
from .commonPy.utility import panic  # NOQA pylint: disable=unused-import


def main() -> None:
    if "-v" in sys.argv:
        import pkg_resources  # pragma: no cover
        version = pkg_resources.require("dmt")[0].version  # pragma: no cover
        print("badTypes v" + str(version))  # pragma: no cover
        sys.exit(1)  # pragma: no cover

    # No other options must remain in the cmd line...
    if len(sys.argv) < 2:
        panic('Usage: %s input1.asn [input2.asn] ...\n' % sys.argv[0])  # pragma: no cover
    for f in sys.argv[1:]:
        if not os.path.isfile(f):
            panic("'%s' is not a file!\n" % f)  # pragma: no cover

    asn1files = sys.argv[1:]
    asnParser.ParseAsnFileList(asn1files)
    names = asnParser.g_names
    for node in names.values():
        verify.VerifyRanges(node, names)

    # If some AST nodes must be skipped (for any reason), go learn about them
    badTypes = DiscoverBadTypes()
    print("\n".join(badTypes))


if __name__ == "__main__":
    if "-pdb" in sys.argv:
        sys.argv.remove("-pdb")  # pragma: no cover
        import pdb  # pragma: no cover pylint: disable=wrong-import-position,wrong-import-order
        pdb.run('main()')  # pragma: no cover
    else:
        main()
